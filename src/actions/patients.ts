"use server";

import { actionClient } from "@/lib/safe-action";
import { db } from "@/lib/db";
import { patient } from "@/lib/db/schema";
import { desc, eq, sql } from "drizzle-orm";
import { flattenValidationErrors } from "next-safe-action";
import type { InferInsertModel } from "drizzle-orm";
import { z } from "zod";

// Validation Schemas
import {
  createPatientSchema,
  updatePatientSchema,
} from "@/lib/validation/patients";

export const getAllPatients = actionClient
  .metadata({ actionName: "getAllPatients" })
  .action(async () => {
    const patients = await db.query.patient.findMany({
      orderBy: [desc(patient.createdAt)],
    });

    return patients;
  });

/**
 * Obtiene pacientes agrupados por día de creación
 * Retorna un objeto donde las claves son fechas (YYYY-MM-DD) y los valores son arrays de pacientes
 */
export const getPatientsByDay = actionClient
  .metadata({ actionName: "getPatientsByDay" })
  .action(async () => {
    const patients = await db.query.patient.findMany({
      orderBy: [desc(patient.createdAt)],
    });

    // Agrupar pacientes por día
    const patientsByDay: Record<string, typeof patients> = {};

    patients.forEach((patient) => {
      const dateKey = patient.createdAt.toISOString().split("T")[0]; // YYYY-MM-DD
      if (!patientsByDay[dateKey]) {
        patientsByDay[dateKey] = [];
      }
      patientsByDay[dateKey].push(patient);
    });

    // Convertir a array ordenado por fecha (más reciente primero)
    const sortedDays = Object.entries(patientsByDay).sort((a, b) =>
      b[0].localeCompare(a[0])
    );

    return sortedDays.map(([date, patients]) => ({
      date,
      patients,
      count: patients.length,
    }));
  });

export const getPatientById = actionClient
  .metadata({ actionName: "getPatientById" })
  .inputSchema(z.object({ id: z.coerce.number() }))
  .action(async ({ parsedInput }) => {
    const foundPatient = await db.query.patient.findFirst({
      where: eq(patient.id, parsedInput.id),
    });

    if (!foundPatient) {
      throw new Error("Paciente no encontrado");
    }

    return foundPatient;
  });

export const createPatient = actionClient
  .metadata({ actionName: "createPatient" })
  .inputSchema(createPatientSchema, {
    handleValidationErrorsShape: async (errors) => {
      return flattenValidationErrors(errors).fieldErrors;
    },
  })
  .action(async ({ parsedInput }) => {
    // createdAt and updatedAt are auto-generated by the database
    const insertData: InferInsertModel<typeof patient> = {
      id: parsedInput.id,
      firstName: parsedInput.firstName,
      lastName: parsedInput.lastName,
      phone: parsedInput.phone,
    };

    const [newPatient] = await db
      .insert(patient)
      .values(insertData)
      .returning();

    return {
      patient: newPatient,
      message: "Paciente creado correctamente.",
    };
  });

export const updatePatient = actionClient
  .metadata({ actionName: "updatePatient" })
  .inputSchema(updatePatientSchema, {
    handleValidationErrorsShape: async (errors) => {
      return flattenValidationErrors(errors).fieldErrors;
    },
  })
  .action(async ({ parsedInput }) => {
    // Check if patient exists
    const existingPatient = await db.query.patient.findFirst({
      where: eq(patient.id, parsedInput.id),
    });

    if (!existingPatient) {
      throw new Error("Paciente no encontrado");
    }

    // updatedAt is auto-generated by the database
    const [updatedPatient] = await db
      .update(patient)
      .set({
        firstName: parsedInput.firstName,
        lastName: parsedInput.lastName,
        phone: parsedInput.phone,
        updatedAt: new Date(),
      })
      .where(eq(patient.id, parsedInput.id))
      .returning();

    return {
      patient: updatedPatient,
      message: "Paciente actualizado correctamente.",
    };
  });
