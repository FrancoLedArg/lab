"use server";

import { actionClient } from "@/lib/safe-action";
import { db } from "@/lib/db";
import { patient } from "@/lib/db/schema";
import { desc, eq } from "drizzle-orm";
import { flattenValidationErrors } from "next-safe-action";
import type { InferInsertModel } from "drizzle-orm";
import { z } from "zod";

// Validation Schemas
import {
  createPatientSchema,
  updatePatientSchema,
} from "@/lib/validation/patients";

export const getAllPatients = actionClient
  .metadata({ actionName: "getAllPatients" })
  .action(async () => {
    const patients = await db.query.patient.findMany({
      orderBy: [desc(patient.createdAt)],
    });

    return patients;
  });

export const getPatientById = actionClient
  .metadata({ actionName: "getPatientById" })
  .inputSchema(z.object({ id: z.coerce.number() }))
  .action(async ({ parsedInput }) => {
    const foundPatient = await db.query.patient.findFirst({
      where: eq(patient.id, parsedInput.id),
    });

    if (!foundPatient) {
      throw new Error("Paciente no encontrado");
    }

    return foundPatient;
  });

export const createPatient = actionClient
  .metadata({ actionName: "createPatient" })
  .inputSchema(createPatientSchema, {
    handleValidationErrorsShape: async (errors) => {
      return flattenValidationErrors(errors).fieldErrors;
    },
  })
  .action(async ({ parsedInput }) => {
    // createdAt and updatedAt are auto-generated by the database
    const insertData: InferInsertModel<typeof patient> = {
      id: parsedInput.id,
      firstName: parsedInput.firstName,
      lastName: parsedInput.lastName,
      phone: parsedInput.phone,
    };

    const [newPatient] = await db
      .insert(patient)
      .values(insertData)
      .returning();

    return {
      patient: newPatient,
      message: "Paciente creado correctamente.",
    };
  });

export const updatePatient = actionClient
  .metadata({ actionName: "updatePatient" })
  .inputSchema(updatePatientSchema, {
    handleValidationErrorsShape: async (errors) => {
      return flattenValidationErrors(errors).fieldErrors;
    },
  })
  .action(async ({ parsedInput }) => {
    // Check if patient exists
    const existingPatient = await db.query.patient.findFirst({
      where: eq(patient.id, parsedInput.id),
    });

    if (!existingPatient) {
      throw new Error("Paciente no encontrado");
    }

    // updatedAt is auto-generated by the database
    const [updatedPatient] = await db
      .update(patient)
      .set({
        firstName: parsedInput.firstName,
        lastName: parsedInput.lastName,
        phone: parsedInput.phone,
        updatedAt: new Date(),
      })
      .where(eq(patient.id, parsedInput.id))
      .returning();

    return {
      patient: updatedPatient,
      message: "Paciente actualizado correctamente.",
    };
  });
